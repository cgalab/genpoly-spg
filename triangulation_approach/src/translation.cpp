#include "translation.h"

/*
	S ~ T ~ A ~ T ~ I ~ C 	V ~ A ~ R ~ I ~ A ~ B ~ L ~ E ~ S
*/

/*
	The number of already generated vertices
*/
unsigned long long Translation::n = 0;


/*
	P ~ R ~ I ~ V ~ A ~ T ~ E 	M ~ E ~ M ~ B ~ E ~ R 	F ~ U ~ N ~ C ~ T ~ I ~ O ~ N ~ S
*/

/*
	Private Constructor:
	Generates a new translation of any type, whereas the publiuc constructor is just capable
	of generating translations of type DEFAULT. Grep the moving vertex and its neighbors from
	the triangulations vertices list and initalize the translation path.

	@param 	Tr 		The triangulation the moving vertex lives in
	@param 	i 		The index of the moving vertex in the triangulation
	@param 	dX 		The x-component of the translation vector
	@param 	dY 		The y-component of the translation vector
	@param	type 	The type of the translation

	Note:
		A translation of non-DEFAULT type can just be generated by a DEFAULT translation which
		must be split.
*/
Translation::Translation(Triangulation *Tr, int i, double dX, double dY, TranslationType tp) : 
	T(Tr), index(i), dx(dX), dy(dY), split(false), type(tp), actualTime(0), id(n){

	original = (*T).getVertex(index);

	prevV = (*original).getPrev();
	nextV = (*original).getNext();

	oldV = (*original).getTranslated(0, 0);
	newV = (*original).getTranslated(dx, dy);

	transPath = new TEdge(oldV, newV);

	prevOldE = (*original).getToPrev();
	nextOldE = (*original).getToNext();

	prevNewE = new TEdge(prevV, newV);
	nextNewE = new TEdge(newV, nextV);

	Q = new EventQueue(original, oldV, newV);

	n++;
}

/*
	The function generateInitialQueue() generates the initial version of the event queue. Therefore
	it decides for each triangle containing the moving vertex, whether the triangle will collapse
	during the translation. To achieve this it gets checked whether the opposite edge of the triangle
	lays between the start and the target position of the moving vertex.
	After inserting all collapsing triangles with their estimated collapse times into the event queue
	it lets check the event queue the stability of the event ordering and try to repair.

	@return 	True if the event queue is stable, otherwise false

	Note:
		This function also checks whether any of the triangles is zero and tries to repair it. If
		it finds something not repairable it erros with exit code 7.
*/
bool Translation::generateInitialQueue(){
	double t;
	std::list<Triangle*> triangles = (*original).getTriangles();
	TEdge *opposite;
	Vertex *v0, *v1;
	double areaOld, areaNew;
	Triangle *tr;
	bool ok;

	for(auto& i : triangles){
		opposite = (*i).getEdgeNotContaining(original);
		v0 = (*opposite).getV0();
		v1 = (*opposite).getV1();

		tr = new Triangle(v0, v1, oldV);
		areaOld = (*tr).signedArea();
		delete tr;

		// If the vertex lays at an edge at the begining of the translation then try to flip
		if(areaOld == 0){
			opposite = (*i).getLongestEdgeAlt();

			// If the longest edge is a polygon edge, then we have an error here
			if((*opposite).getEdgeType() == EdgeType::POLYGON){
				printf("The vertex %llu to be translated lays exactly on a polygon edge :0\n", (*original).getID());
				exit(7);
			}

			// Otherwise we can do a flip, but will reject the translation because this flip will
			// crash the iterator of this loop
			if(Settings::correctionInfo)
				printf("Numerical correction: The moving vertex lays exactly on an edge before the translation -> security flip\n");

			flip(i, true);
			return false;
		}

		tr = new Triangle(v0, v1, newV);
		areaNew = (*tr).signedArea();
		delete tr;

		// Note: the triangle will also collapse if areaNew is exactly zero (zero can have both signs)
		if((areaNew != 0) && (signbit(areaOld) == signbit(areaNew)))
			continue;
		else{
			t = (*i).calculateCollapseTime(original, dx, dy);

			if(t < 0){
				if(Settings::correctionInfo)
					printf("Numerical correction: Collapse time of collapsing triangle was %.20f \n", t);

				t = 0;
			}

			if(t > 1){
				if(Settings::correctionInfo)
					printf("Numerical correction: Collapse time of collapsing triangle was %.20f \n", t);

				t = 1;
			}

			(*i).enqueue();

			(*Q).insertWithoutCheck(t, i);
		}
	}

	ok = (*Q).makeStable(true);

	return ok;
}

/*
	The function insideQuadrilateral() checks whether the vertex v lays inside of a quadrilateral
	formed by the edge from oldV to its neighboring  vertices and from newV to its neighboring
	vertices.
	Therefore it generates a dummy vertex with the same y-coordinate as v and a x-coordinate which
	is the maximum x-coordinate of all vertices of the quadrilateral plus 10. So the dummy vertex
	lays definitelly lays outside of the qudrilateral. Then it checks how often the edge between v
	and the dummy vertex intersects the edges of the quadrilateral. If the number of intersections
	is odd, then v must lay inside of the quadrilateral.

	@param 	v 	The vertex of interest
	@return 	True if v is inside of the quadrilateral, otherwise false

	Note:
		- Source: https://www.geeksforgeeks.org/how-to-check-if-a-given-point-lies-inside-a-polygon/
		- If the dummy edge intersects exactly at a vertex, we will get intersections with two edges,
			which makes the function think, that the vertex is outside of the quadrilateral.
			Therefore the function automatically returns true, if it gets two or more vertex
			intersection anywhere. This leads to rejecting the translation.
*/
bool Translation::insideQuadrilateral(Vertex * const v) const{
	Vertex *dummyVertex;
	TEdge *dummyEdge;
	double maxX, x;
	int count = 0;
	IntersectionType intersection;
	bool vertexInt = false;

	// Find maximum x value
	maxX = (*oldV).getX();
	x = (*newV).getX();
	if(x > maxX)
		maxX = x;
	x = (*prevV).getX();
	if(x > maxX)
		maxX = x;
	x = (*nextV).getX();
	if(x > maxX)
		maxX = x;

	// If v has a greater x-coordinate then all quadrilateral vertices, it can not be inside
	if((*v).getX() > maxX)
		return false;

	// Generate the dummy vertex outside of the quadrilateral
	maxX = maxX + 10;
	dummyVertex = new Vertex(maxX, (*v).getY());

	dummyEdge = new TEdge(v, dummyVertex);

	// Count the intersection
	intersection = checkIntersection(dummyEdge, prevOldE, false);
	if(intersection == IntersectionType::VERTEX)
		vertexInt = true;
	if(intersection != IntersectionType::NONE)
		count++;

	intersection = checkIntersection(dummyEdge, nextOldE, false);
	if(intersection == IntersectionType::VERTEX)
		vertexInt = true;
	if(intersection != IntersectionType::NONE)
		count++;

	intersection = checkIntersection(dummyEdge, prevNewE, false);
	if(intersection == IntersectionType::VERTEX)
		vertexInt = true;
	if(intersection != IntersectionType::NONE)
		count++;

	intersection = checkIntersection(dummyEdge, nextNewE, false);
	if(intersection == IntersectionType::VERTEX)
		vertexInt = true;
	if(intersection != IntersectionType::NONE)
		count++;

	delete dummyEdge;
	delete dummyVertex;

	// If there was any intersection of type vertex return false, so the translation gets
	// refused. The point is, for an vertex intersection we can not say anything for sure
	// espacially as the dummeEdge could just intersect with any point of the quadrilateral.
	if(vertexInt)
		return false;

	if(count % 2 == 1)
		return true;
	else
		return false;
}

/*
	The function insideTriangle() checks whether the vertex toCheck is inside the triangle
	formed by the vertices v0, v1 and v2.

	@param	v0 			First veretx of the triangle
	@param 	v1 			Second vertex of the triangle
	@param 	v2 			Third vertex of the triangle
	@param 	toCheck 	The vertex for which should be checked whether it lays inside the
						triangle or not
	@return 			True if toCheck lays inside the triangle, otherwise false
*/
bool Translation::insideTriangle(Vertex * const v0, Vertex * const v1, Vertex * const v2,
	Vertex * const toCheck){
	double area0, area1;
	Triangle *t;

	t = new Triangle(v0, v1, toCheck);
	area0 = (*t).signedArea();
	delete t;

	t = new Triangle(v1, v2, toCheck);
	area1 = (*t).signedArea();
	delete t;

	if(signbit(area0) != signbit(area1))
		return false;

	t = new Triangle(v2, v0, toCheck);
	area1 = (*t).signedArea();
	delete t;

	if(signbit(area0) != signbit(area1))
		return false;

	return true;
}

/*
	The function checkEdge() checks whether the edge newE starting at vertex fromV intersects any
	polygon edge. Therefore it first checks whether newE intersects any edge of the surrounding
	polygon of fromV. If it does not, then it can not intersect any polygon edge, otherwise we
	continue the check in the other triangle assigned to the intersected edge until newE either
	intersects a polygon edge or ends in any triangle.

	@param 	fromV 	The vertex where the new edge starts
	@param 	newE 	The new edge
	@return 		True if the new edge does not intersect any polygon edge, otherwise false

	Note:
		- If the edge goes right through another vertex we also count it as intersecting a polygon
			edge even if the edge we checked was no polygon edge, because a new polygon edge
			obviously is not allowed to go through a vertex.
		- As we had the case that a new edge numerically intersected all three edges of the same
			triangle or multiple edges of the surrounding polygon we do not stopp at the first 
			intersection we find, but we count all intersections. If we find more then one, the
			function returns false. But this should now really happen nowhere as the epsilon
			in checkIntersection() should lead to getting all these cases as intersections of
			type VERTEX.
		- Edges of the bounding box are treated as polygon edges
*/
bool Translation::checkEdge(Vertex * const fromV, TEdge * const newE) const{
	std::vector<TEdge*> surEdges;
	enum IntersectionType iType = IntersectionType::NONE;
	enum IntersectionType iType0, iType1;
	TEdge *intersectedE = NULL;
	EdgeType eType;
	Triangle *nextT = NULL;
	int count = 0;

	surEdges = (*fromV).getSurroundingEdges();

	// Iterate over all edges of the surrounding polygon
	for(auto& i : surEdges){
		iType = checkIntersection(newE, i, false);

		// New edge hits vertex of surrounding polygon
		if(iType == IntersectionType::VERTEX)
			return false;

		// Count intersections to detect numerical errors
		if(iType == IntersectionType::EDGE){
			count++;
			intersectedE = i;
		}
	}

	// No intersection -> the new vertex stays in the surrounding polygon
	if(count == 0){
		return true;
	// Multiple intersections -> numerical error
	}else if(count > 1){
		if(Settings::correctionInfo)
			printf("CheckEdge: new edge intersects multiple edges of the surrounding polygon -> translation rejected due to numerical problem\n");
		
		return false;
	}

	// One real intersection with an edge of the surrounding polygon
	eType = (*intersectedE).getEdgeType();

	// Intersected edge is a polygon or frame edge
	if(eType != EdgeType::TRIANGULATION){
		return false;
	// Intersected edge is just a triangulation edge
	}else{
		nextT = (*intersectedE).getTriangleNotContaining(fromV);
		surEdges = (*nextT).getOtherEdges(intersectedE);
	}

	// Iterate over the adjacent triangles if there was an intersection with a triangulation edge
	// Here surEdges always have the length 2
	while(true){
		iType0 = checkIntersection(newE, surEdges[0], false);
		iType1 = checkIntersection(newE, surEdges[1], false);

		// The new edge does not interesect any further edges
		if(iType0 == IntersectionType::NONE && iType1 == IntersectionType::NONE)
			return true;

		// New edge hits a vertex
		if(iType0 == IntersectionType::VERTEX) 
			return false;
		if(iType1 == IntersectionType::VERTEX) 
			return false;

		// Check for numerical problems
		if(iType0 != IntersectionType::NONE && iType1 != IntersectionType::NONE){
			if(Settings::correctionInfo)
				printf("CheckEdge: new edge intersects multiple edges of the actual triangle -> translation rejected due to numerical problem\n");
			
			return false;
		}

		// Choose the intersected edge
		if(iType0 != IntersectionType::NONE){
			iType = iType0;
			intersectedE = surEdges[0];
		}else{
			iType = iType1;
			intersectedE = surEdges[1];
		}

		eType = (*intersectedE).getEdgeType();

		// intersected edge is a polygon or frame edge
		if(eType != EdgeType::TRIANGULATION){
			return false;
		// Intersected edge is just a triangulation edge
		}else{
			nextT = (*intersectedE).getOtherTriangle(nextT);
			surEdges = (*nextT).getOtherEdges(intersectedE);
		}
	}

	return true;
}

/*
	The function repairEnd() checks at the end of a translation whether there exist any triangle
	with area 0 connected to the moving vertex. If such a triangle exists it tries to flip it
	if possible, otherwise it tries to move the vertex back by 10% of the translation.

	Note:
		As the checkIntersection functions tries to keep vertices far from edges this should never
		be the case besides such splitted translation where the vertex is moved exactly to a
		triangulation edge on purpose.
*/
void Translation::repairEnd(){
	std::list<Triangle*> triangles;
	double area;
	TEdge *edge;
	Translation *trans;
	enum Executed ex;

	triangles = (*original).getTriangles();

	for(auto& i : triangles){
		area = (*i).signedArea();

		if(area == 0){
			if(type == TranslationType::DEFAULT && Settings::correctionInfo){
				printf("Translation: Triangle area = 0 after translation...");
			}

			edge = (*i).getLongestEdgeAlt();

			// Try to do a security flip
			if((*edge).getEdgeType() != EdgeType::POLYGON)
				flip(i, true);
			// Otherwise try to move the vertex back a bit
			else{

				trans = new Translation(T, index, - dx * 0.1, - dy * 0.1);
				ex = (*trans).execute();
				delete trans;

				if(ex == Executed::REJECTED){
					printf("\nTriangle area = 0 after translation: PE can not be fliped\n");
					exit(2);
				}
			}

			if(type == TranslationType::DEFAULT && Settings::correctionInfo)
				printf("corrected! \n");
		}
	}
}

/*
	The function executeSplitRetainSide() decomposes one translation, which can not be executed
	directly and where the moving vertex stays at the same side of the edge connecting the
	neighboring vertices, and executes the resulting translations. The decomposition is done
	in the following way:
	1. The vertex is moved to the position where the edge from the previous vertex to the old
		position intersects the edge from the next vertex to the new position resp. the edge
		from the next vertex to the old position intersects the edge from the previous vertex
		to the new position (exactly one of the two pairs of edges intersects!)
	2. The vertex is moved from the intersection position of the first part to the final
		position.

	@return 	Indicates whether the execution was rejected, aborted or fully processed

	Note:
		For detailed information why we can do that take a look at my Master Thesis
*/
enum Executed Translation::executeSplitRetainSide() const{
	Vertex *intersectionPoint;
	double transX, transY;
	Translation *trans;
	enum Executed ex;

	// Compute the intersection point to split the translation
	intersectionPoint = getIntersectionPoint(prevOldE, nextNewE);
	if(intersectionPoint == NULL)
		intersectionPoint = getIntersectionPoint(nextOldE, prevNewE);
	if(intersectionPoint == NULL){
		return Executed::REJECTED;
	}

	// First part of the translation to the intersection point
	transX = (*intersectionPoint).getX() - (*oldV).getX();
	transY = (*intersectionPoint).getY() - (*oldV).getY();

	trans = new Translation(T, index, transX, transY, TranslationType::SPLIT_PART_1);
	ex = (*trans).execute();

	delete intersectionPoint;
	delete trans;

	if(ex != Executed::FULL)
		return ex;

	// Second part of the translation from the intersection point to the target point
	transX = (*newV).getX() - (*original).getX();
	transY = (*newV).getY() - (*original).getY();

	trans = new Translation(T, index, transX, transY, TranslationType::SPLIT_PART_2);
	ex = (*trans).execute();

	delete trans;

	if(ex == Executed::FULL)
		return ex;
	else
		return Executed::PARTIAL;
}

/*
	The function executeSplitChangeSide() decomposes one translation, which can not be
	executed directly and where the moving vertex changes the side of the edge connecting
	the neighboring vertices, and executes the resulting translations. The decomposition
	is done in the following way:
	1. The vertex is moved exactly at the middle between the two neighboring vertices.
	2. The vertex is moved from the position between the two neighboring vertices to its
		final position.

	@return 	Indicates whether the execution was rejected, aborted or fully processed

	Note:
		For detailed information why we can do that take a look at my Master Thesis
*/
enum Executed Translation::executeSplitChangeSide(){
	double middleX, middleY;
	double transX, transY;
	Translation *trans;
	enum Executed ex;
	TEdge *edge;
	Triangle *t;

	// Get translation to end position of the first part which is the middle between the
	// neighboring vertices
	middleX = ((*prevV).getX() + (*nextV).getX()) / 2;
	middleY = ((*prevV).getY() + (*nextV).getY()) / 2;

	// Compute translation vector
	transX = middleX - (*oldV).getX();
	transY = middleY - (*oldV).getY();

	trans = new Translation(T, index, transX, transY, TranslationType::SPLIT_PART_1);
	ex = (*trans).execute();

	delete trans;

	if(ex != Executed::FULL)
		return ex;

	// For numerical reasons it is possible that the triangle of the old vertex and the
	// neighboring vertices doesn't vanish at the time when the vertex arrives between its
	// neighbors, therefore this must be checked and corrected before starting the second
	// translation
	edge = (*prevV).getEdgeTo(nextV);
	if(edge != NULL){
		t = (*edge).getTriangleContaining(original);
		flip(t, true);
	}

	// Get translation from middle to the target position
	transX = (*newV).getX() - (*original).getX();
	transY = (*newV).getY() - (*original).getY();

	trans = new Translation(T, index, transX, transY, TranslationType::SPLIT_PART_2);
	ex = (*trans).execute();

	delete trans;

	if(ex == Executed::FULL)
		return ex;
	else
		return Executed::PARTIAL;
}

/*
	The function flip() executes one event by removing the longest edge of the collapsing
	triangle and inserting the other diagonal of the resulting quadrilateral. It errors
	with exit code 3 if the longest edge is a polygon edge. If the flip is no singleFlip
	it also computes whether the the two resulting triangles will also collapse during the
	further translation and in case insert them into the event queue and check its stability.
	This computation is outsourced to the functions insertAfterOppositeFlip() and
	insertAfterNonOppositeFlip().

	@param 	t0 			The collapsing triangle
	@param 	singleFlip 	Indicates whether this flip is part of working off the event queue,
						or it is just a single security flip
	@return 			True if the event queue is still stable, otherwise false

	Note:
		- It is assumed that the area of the collapsing triangle is zero (or at least close
			to 0), i.e. the moving vertex is already shifted to the event time
		- Checking whether a resulting triangle will collapse during the further translation
			is a highly sensible thing! It is not recommend to use the actual position of
			the moving vertex therefore, because the small errors in its position can lead
			to wrong decisions
		- For more information on the method of deciding take a look into my Master Thesis
*/
bool Translation::flip(Triangle *t0, const bool singleFlip){
	TEdge *e, *e1, *e2;
	Triangle *t1;
	Vertex *vj0, *vj1; // Joint vertices
	Vertex *vn0, *vn1; // Non-joint vertices
	// We call it an opposite flip, if the flipped edge is the one opposite to the moving vertex
	// i.e. it doesn't contain the moving vertex
	bool oppositeFlip = false;
	double x, y;
	// Indicates whether a new triangle has been inserted into the eventqueue
	bool insertion = false; 
	Vertex *common, *opposite;

	if(!singleFlip)
		// Move vertex to event time
		(*original).setPosition((*oldV).getX() + dx * actualTime, (*oldV).getY() + dy * actualTime);

	// Get the edge which should be flipped
	e = (*t0).getLongestEdgeAlt();
	if((*e).getEdgeType() == EdgeType::POLYGON){
		printf("Flip: polygon edge gets deleted\n");
		printf("id: %llu index: %d dx: %f dy: %f \n", (*original).getID(), index, dx, dy);

		(*T).check();
		exit(3);
	}

	// Check for flip type
	if(!(*e).contains(original))
		oppositeFlip = true;

	// Remove the other triangle from the eventqueue if it is enqueued
	t1 =(*e).getOtherTriangle(t0);
	if((*t1).isEnqueued())
		(*Q).remove(t1);

	// Get all vertices of the triangles which are removed
	vj0 = (*e).getV0();
	vj1 = (*e).getV1();
	vn0 = (*t0).getOtherVertex(e);
	vn1 = (*t1).getOtherVertex(e);

	// This automatically also deletes the two triangles
	delete e;

	// New triangle vn0, vn1, vj0
	e = new TEdge(vn0, vn1);
	(*T).addEdge(e);

	e1 = (*vj0).getEdgeTo(vn0);
	e2 = (*vj0).getEdgeTo(vn1);

	t0 = new Triangle(e, e1, e2, vn0, vn1, vj0);

	// New triangle vn0, vn1, vj1
	(*T).addEdge(e);

	e1 = (*vj1).getEdgeTo(vn0);
	e2 = (*vj1).getEdgeTo(vn1);

	t1 = new Triangle(e, e1, e2, vn0, vn1, vj1);

	if(!singleFlip){
		
		// Add the flip to the flip stack
		if(Settings::localChecking)
			FlipStack.push(new Flip(vj0, vj1, vn0, vn1));

		// Reset coordinates temporarely to original position for the calcalation of the event time
		x = (*original).getX();
		y = (*original).getY();
		(*original).setPosition((*oldV).getX(), (*oldV).getY());

		if(oppositeFlip){
			
			// Decide which vertex is the non-moving vertex both new triangles share for an
			// opposite flip 
			if((*original).getID() == (*vn0).getID())
				common = vn1;
			else
				common = vn0;

			insertion = insertAfterOppositeFlip(t0, t1, vj0, vj1, common);

		}else{
			
			// Decide which vertex is the non-shared vertex of the triangle which does not
			// change anymore
			if((*vj0).getID() == (*original).getID())
				opposite = vj1;
			else
				opposite = vj0;

			// Get the triangle which still contains the moving vertex
			if((*t0).contains(original))
				insertion = insertAfterNonOppositeFlip(t0, vn0, vn1, opposite);
			else
				insertion = insertAfterNonOppositeFlip(t1, vn0, vn1, opposite);
		}

		// Get original back to its actual position
		(*original).setPosition(x, y);		

		if(insertion)
			return (*Q).makeStable(false);
		else
			return true;
	}

	return true;
}

/*
	The function insertAfterOppositeFlip() decides whether newly generated triangles after
	an opposite flip (the edge not containing the moving vertex has been flipped) has to be
	inserted into the event queue. Therefore it does not use the actual position of the 
	moving vertex as this position may be corrupted by numerical inaccuracies. Instead just
	all static vertices of the triangles are used.

	@param 	leftT 	The left one of the new triangles
	@param 	rightT 	The right one of the new triangles
	@param 	leftV 	The vertex which is only contained by the left triangle
	@param 	rightV 	The vertex which is only contained by the right triangle
	@param 	common 	The vertex which is contained by both triangles, but is not the moving
					vertex
	@return 		True if one of the triangles has been inserted into the event queue,
					otherwise false

	Note:
		- For detailed information on the decision criteria take a look into my Master Thesis
		- Left and right may not be really left and right, but this does not matter as long
			as leftV corresponds to leftT and rightV to rightT
*/
bool Translation::insertAfterOppositeFlip(Triangle * leftT, Triangle * rightT, Vertex *leftV,
	Vertex * rightV, Vertex * common) const{

	Vertex *dummyVertex;
	Triangle *dummyTriangle;
	double area0, area1, time;
	bool insertion = false;

	// First decide whether the common vertex is inside the corridor built by the two lines
	// parallel to the transition line through the non-shared vertices
	dummyVertex = (*leftV).getTranslated(dx, dy);
	dummyTriangle = new Triangle(leftV, dummyVertex, common);
	area0 = (*dummyTriangle).signedArea();
	delete dummyTriangle;
	delete dummyVertex;

	dummyVertex = (*rightV).getTranslated(dx, dy);
	dummyTriangle = new Triangle(rightV, dummyVertex, common);
	area1 = (*dummyTriangle).signedArea();
	delete dummyTriangle;
	delete dummyVertex;

	// The common vertex is inside the corridor
	// i.e. both new triangles will collapse in the future
	if(signbit(area0) != signbit(area1)){
		// Now we have to check for both new triangles, whether they collapse before
		// the end of the translation

		// For leftT (consisting of leftV, common and original)
		// we have to check the edge from the common vertex to leftV
		dummyTriangle = new Triangle(leftV, common, oldV);
		area0 = (*dummyTriangle).signedArea();
		delete dummyTriangle;

		dummyTriangle = new Triangle(leftV, common, newV);
		area1 = (*dummyTriangle).signedArea();
		delete dummyTriangle;

		// Note: the triangle will also collapse if the test triangle with the new
		// vertex is exact zero (which can have both signs)
		if((area1 == 0) || (signbit(area0) != signbit(area1))){
			time = (*leftT).calculateCollapseTime(original, dx, dy);
			(*Q).insertWithoutCheck(time, leftT);
			(*leftT).enqueue();
			insertion = true;
		}

		// For rightT (consisting of rightV, common and original)
		// we have to check the edge from the common vertex to rightV
		dummyTriangle = new Triangle(rightV, common, oldV);
		area0 = (*dummyTriangle).signedArea();
		delete dummyTriangle;

		dummyTriangle = new Triangle(rightV, common, newV);
		area1 = (*dummyTriangle).signedArea();
		delete dummyTriangle;

		// Note: the triangle will also collapse if the test triangle with the new
		// vertex is exact zero (which can have both signs)
		if((area1 == 0) || (signbit(area0) != signbit(area1))){
			time = (*rightT).calculateCollapseTime(original, dx, dy);
			(*Q).insertWithoutCheck(time, rightT);
			(*rightT).enqueue();
			insertion = true;
		}

	// The common vertex is outside of the corridor
	}else{
		// Now we have to find out which of the two new triangles is the one which collapses
		// in the future

		// It holds:
		// If the common vertex lays out to the left, then rightT will collapse

		// Now we can take a look whether the common vertex and the moving vertex are on
		// different sides of the line parallel to the transition line through the leftV

		dummyVertex = (*leftV).getTranslated(dx, dy);

		dummyTriangle = new Triangle(leftV, dummyVertex, common);
		area0 = (*dummyTriangle).signedArea();
		delete dummyTriangle;

		// ALARM:
		// I accidentially assigned both areas to area0, but it worked :O
		// Hopefully it also works if I correct it
		dummyTriangle = new Triangle(leftV, dummyVertex, original);
		area1 = (*dummyTriangle).signedArea();
		delete dummyTriangle;

		delete dummyVertex;

		// If they are on different sides, then rightT is the triangle which will collapse
		// in the future
		if(signbit(area0) == signbit(area1)){
			// Now we have to check whether leftT collapses before the end of the translation
			// i.e. start and end position have to be on different side of the edge from leftV
			// to common

			dummyTriangle = new Triangle(leftV, common, oldV);
			area0 = (*dummyTriangle).signedArea();
			delete dummyTriangle;

			dummyTriangle = new Triangle(leftV, common, newV);
			area1 = (*dummyTriangle).signedArea();
			delete dummyTriangle;

			if((area1 == 0) || (signbit(area0) != signbit(area1))){
				time = (*leftT).calculateCollapseTime(original, dx, dy);
				(*Q).insertWithoutCheck(time, leftT);
				(*leftT).enqueue();
				insertion = true;
			}
		}else{
			// Now we have to check whether righT collapses before the end of the translation
			// i.e. start and end position have to be on different side of the edge from rightV
			// to common

			dummyTriangle = new Triangle(rightV, common, oldV);
			area0 = (*dummyTriangle).signedArea();
			delete dummyTriangle;

			dummyTriangle = new Triangle(rightV, common, newV);
			area1 = (*dummyTriangle).signedArea();
			delete dummyTriangle;

			if((area1 == 0) || (signbit(area0) != signbit(area1))){
				time = (*rightT).calculateCollapseTime(original, dx, dy);
				(*Q).insertWithoutCheck(time, rightT);
				(*rightT).enqueue();
				insertion = true;
			}
		}
	}

	return insertion;
}

/*
	The function insertAfterNonOppositeFlip() decides whether newly generated triangles after
	a non-opposite flip (one of the edges containing the moving vertex has been flipped) has to
	be inserted into the event queue. Therefore it does not use the actual position of the 
	moving vertex as this position may be corrupted by numerical inaccuracies. Instead just
	all static vertices of the triangles are used.

	@param 	t 			The one new triangle which can potentially collapse during the further
						translation
	@param 	shared0 	One of the two vertices which are shared by the two new triangles
	@param 	shared1 	The other of the two shared vertices
	@param 	opposite 	The non-shared vertex of the triangle which does not contain the
						moving vertex
	@return 			True if the triangles has been inserted into the event queue,
						otherwise false

	Note:
		- For detailed information on the decision criteria take a look into my Master Thesis
*/
bool Translation::insertAfterNonOppositeFlip(Triangle *t, Vertex * shared0, Vertex * shared1,
	Vertex *opposite) const{

	Triangle *dummyTriangle;
	double area0, area1, time;

	// The new triangle will collapse in the future if the non-joint vertex of the triangle
	// which won't change anymore is on the same side of the new edge as the target position
	// is

	dummyTriangle = new Triangle(shared0, shared1, opposite);
	area0 = (*dummyTriangle).signedArea();
	delete dummyTriangle;

	dummyTriangle = new Triangle(shared0, shared1, newV);
	area1 = (*dummyTriangle).signedArea();
	delete dummyTriangle;

	// If the vertices are not on different sides, none of the triangles will collapse in
	// the future
	// UNSAVE:
	// area1 == 0
	if((signbit(area0) == signbit(area1))){
		// Now we have to check whether the new triangle will collapse before the
		// translation ends, i.e. the start position end the end position of the movements
		// are on different sides of the new edge which is given by vn0 and vn1

		dummyTriangle = new Triangle(shared0, shared1, oldV);
		area0 = (*dummyTriangle).signedArea();
		delete dummyTriangle;

		if((area1 == 0) || (signbit(area0) != signbit(area1))){
			time = (*t).calculateCollapseTime(original, dx, dy);
			(*Q).insertWithoutCheck(time, t);
			(*t).enqueue();
			return true;
		}
	}

	return false;
}

/*
	The function undo() checks whether moving vertex still lays inside of its 
	surrounding polygon. If it does not the function undoes all executed flips in
	reversed order and sets the moving vertex back to its original position.

	@return 	True if the translation has been undone, otherwise false
*/
bool Translation::undo(){
	struct Flip *f;
	bool ok;
	Vertex *oldD0, *oldD1;
	Vertex *newD0, *newD1;
	TEdge *e;

	if(!Settings::localChecking)
		return false;

	ok = (*original).checkSurroundingPolygon();

	if(!ok){

		if(Settings::correctionInfo)
			printf("Surrounding polygon check after abortion failed...");

		// Undo all flips
		while(!FlipStack.empty()){
			
			f = FlipStack.top();
			FlipStack.pop();

			oldD0 = f -> oldDV0;
			oldD1 = f -> oldDV1;
			newD0 = f -> newDV0;
			newD1 = f -> newDV1;

			// Get the new edge to delete it
			e = (*newD0).getEdgeTo(newD1);

			delete e;

			// Recreate the old edge
			e = new TEdge(oldD0, oldD1);
			(*T).addEdge(e);

			// And the old triangles
			new Triangle(e, (*oldD0).getEdgeTo(newD0), (*oldD1).getEdgeTo(newD0), oldD0, oldD1, newD0);
			new Triangle(e, (*oldD0).getEdgeTo(newD1), (*oldD1).getEdgeTo(newD1), oldD0, oldD1, newD1);

			delete f;
		}

		// Reset the vertex to the start position
		(*original).setPosition((*oldV).getX(), (*oldV).getY());

		if(Settings::correctionInfo)
			printf("translation undone!\n");

		return true;
	}

	return false;
}


/*
	C ~ O ~ N ~ S ~ T ~ R ~ U ~ C ~ T ~ O ~ R ~ S
*/

/*
	Constructor:
	Generates a new Translation of type DEFAULT. Greps the moving vertex and its
	neighbors from the triangulations vertices list and initalize the translation path.

	@param 	Tr 		The triangulation the moving vertex lives in
	@param 	i 		The index of the moving vertex in the triangulation
	@param 	dX 		The x-component of the translation vector
	@param 	dY 		The y-component of the translation vector

	Note:
		Translations of other types can just be generated by the translation class itself.
*/
Translation::Translation(Triangulation *Tr, int i, double dX, double dY) :
	T(Tr), index(i), dx(dX), dy(dY), split(false), type(TranslationType::DEFAULT), actualTime(0), id(n){

	original = (*T).getVertex(index);

	prevV = (*original).getPrev();
	nextV = (*original).getNext();

	oldV = (*original).getTranslated(0, 0);
	newV = (*original).getTranslated(dx, dy);

	transPath = new TEdge(oldV, newV);

	prevOldE = (*original).getToPrev();
	nextOldE = (*original).getToNext();

	prevNewE = new TEdge(prevV, newV);
	nextNewE = new TEdge(newV, nextV);

	Q = new EventQueue(original, oldV, newV);

	n++;
}


/*
	O ~ T ~ H ~ E ~ R ~ S
*/

/*
	The function checkOverroll() checks whether the polygon would change its orientation by
	this translation. This basically means that the moving vertex is shifted across the whole
	polygon which corresponds to all other vertices and edges being inside of the qudrilateral
	formed by the oldV, the newV and their neighboring edges. Obviously if the quadrilateral is
	not simple, this can not happen at all. If the quadrilateral is simple then it corresponds
	to having one of the other vertices of the polygon inside the qudrilateral, because if
	one vertex is inside it follows all other vertices must be inside or at least one is outside
	so it exist at least one edge intersecting the quadrilateral so the translation can not lead
	to a simple polygon at all.
	For polygons with holes it also checks whether the outer polygon rolls over an inner one or
	an inner polygon rolls over another one. Additionally it checks whether a vertex passes one
	of the inner polygons in a way, that one polygon edge would crash into the inner polygon.
	For some of these cases it is possible to solve it by splitting the translation. For these
	cases it sets the split flag of the translation.

	@return 	True if the polygon would change its orientation or rolls over another inner 
				polygon, otherwise false

	Note:
		For more information on how to check which cases can be solved by splitted translations
		take a look at my Master Thesis
*/
bool Translation::checkOverroll(){
	bool overroll;
	Vertex *randomV;
	unsigned int i;
	Triangle *dummy;
	double areaOld, areaNew;
	bool inside0, inside1;

	// At first we check whether the moving vertex passes by another polygon
	// Note:
	// It can just pass by an inner polygon
	for(i = 1; i <= Settings::nrInnerPolygons; i++){

		// Skip the changing polygon itself
		if((*original).getPID() == i)
			continue;

		// Get a random vertex of the polygon
		randomV = (*T).getVertex(0, i);

		inside0 = insideTriangle(oldV, newV, prevV, randomV);
		inside1 = insideTriangle(oldV, newV, nextV, randomV);

		if(inside0 && inside1){
			split = true;
			continue;
		}

		if(inside0 || inside1)
			return true;
	}

	// Now we check whether the polygon rolls over another polygon or itself

	// Check whether the quadrilateral of the choosen Vertex P, its translated version P' and the
	// two neighbors M and N is simple, otherwise there can not be any overroll
	overroll = !(checkIntersection(prevOldE, nextNewE, false) != IntersectionType::NONE || checkIntersection(nextOldE, prevNewE, false) != IntersectionType::NONE);

	if(!overroll)
		return false;


	// Now check for the polygon itself whether another random vertex of it lays inside the polygon,
	// i.e. that its orientation would be changed by the translation

	// Special Case:
	// If the polygon has a size of 3, we have to check whether the moving vertex changes the
	// side of the opposing edge
	if((*original).getActualPolygonSize() == 3){
		dummy = new Triangle(prevV, nextV, oldV);
		areaOld = (*dummy).signedArea();
		delete dummy;

		dummy = new Triangle(prevV, nextV, newV);
		areaNew = (*dummy).signedArea();
		delete dummy;

		if(signbit(areaOld) != signbit(areaNew))
			return true;

	// Default Case:
	}else{
		// Check for vertex before the previous vertex whether it is inside the quadrilateral
		randomV = (*prevV).getPrev();

		overroll = insideQuadrilateral(randomV);

		// Check also for a second vertex to increase the chance to reject non-simple translation
		randomV = (*nextV).getNext();

		overroll = overroll || insideQuadrilateral(randomV);

		if(overroll)
			return true;
	}

	
	// Now we also have to check for all other polygons whether the polygon which is changing
	// rolls over them

	// Note:
	// It is not possible that an inner polygon rolls over the outer one, so here we
	// just have to check the inner ones

	for(i = 1; i <= Settings::nrInnerPolygons; i++){

		// Skip the changing polygon itself
		if((*original).getPID() == i)
			continue;

		// Get a random vertex of the polygon
		randomV = (*T).getVertex(0, i);

		overroll = insideQuadrilateral(randomV);

		if(overroll)
			return true;
	}

	return false;
}

/*
	The function execute() processes a translation. If the flag split is set, it calls the
	functions which split the translation into two translations (depending on the geometric
	case) and executes them, otherwise execute() executes the translation by successively
	working through the events in the event queue.

	@return 	Indicates whether the execution was rejected, aborted or fully processed

	Note:
		For more information on the splits see my Master Thesis
*/
enum Executed Translation::execute(){
	Triangle *t = NULL;
	std::pair<double, Triangle*> e;
	double oldArea, newArea;
	bool undone;

	// The translation must be split into two translations
	if(split){
		t = new Triangle(prevV, nextV, oldV);
		oldArea = (*t).signedArea();
		delete t;

		t = new Triangle(prevV, nextV, newV);
		newArea = (*t).signedArea();
		delete t;

		// Vertex stays on the same side of the edge between the neighboring vertices
		if(signbit(oldArea) == signbit(newArea))
			return executeSplitRetainSide();
		// Vertex changes side
		else
			return executeSplitChangeSide();
	
	// Default translation
	}else{
		
		if(!generateInitialQueue())
			return Executed::REJECTED;

		// Do till all events are processed
		while((*Q).size() > 0){
			e = (*Q).pop();
			actualTime = e.first;
			t = e.second;

			// Abort if the event queue becomes unstable
			if(!flip(t, false)){
				undone = undo();
				if(undone)
					return Executed::UNDONE;
				else
					return Executed::PARTIAL;
			}
		}

		// Move the vertex to its target position
		(*original).setPosition((*newV).getX(), (*newV).getY());

		return Executed::FULL;
	}
}

/*
	The function checkSimplicityOfTranslation() determines whether the result of a translation is
	a simple polygon. It does so by checking whether one of the edges from the new vertex position
	to one of its neighbors intersects a polygon edge.

	@return 	True if the resulting polygon is still simple, otherwise false
*/
bool Translation::checkSimplicityOfTranslation() const{
	bool simple;

	(*prevOldE).setEdgeType(EdgeType::TRIANGULATION);
	(*nextOldE).setEdgeType(EdgeType::TRIANGULATION);

	simple = checkEdge(prevV, prevNewE);
	simple = simple && checkEdge(nextV, nextNewE);

	(*prevOldE).setEdgeType(EdgeType::POLYGON);
	(*nextOldE).setEdgeType(EdgeType::POLYGON);

	return simple;
}

/*
	The function checkSplit() determines whether a translation can be executed directly or must
	be split into two translation. This corresponds to the question whether the translation path
	intersects any polygon edge or not. If the translation must be split the function sets the
	internal split flag. If the split flag was already set by the function checkOverroll() it 
	does nothing.
*/
void Translation::checkSplit(){
	// In case the checkOverroll() has already demanded a split
	if(split)
		return;

	split = !checkEdge(original, transPath);
}


/*
	D ~ E ~ S ~ T ~ R ~ U ~ C ~ T ~ O ~ R
*/

/*
	Destructor:
	Checks and potentially repairs the surrounding polygon of the moved vertex and deletes all
	the remaining construction vertices and edges. It errors with exit code 6 if the surrounding
	polygon check fails. It also deletes the flip stack.
*/	
Translation::~Translation(){
	bool ok;
	struct Flip *f;

	// Delete the flip stack
	while(!FlipStack.empty()){
		f = FlipStack.top();
		FlipStack.pop();

		delete f;
	}

	repairEnd();

	ok = (*original).checkSurroundingPolygon();

	if(!ok){
		printf("\nstart position:\n");
		(*oldV).print();
		printf("original position:\n");
		(*original).print();
		printf("target position:\n");
		(*newV).print();
		printf("translation vector: dx = %.20f dy = %.20f \n", dx, dy);

		(*T).writeTriangulation("bug.graphml");

		exit(6);
	}

	delete transPath;
	delete oldV;
	delete newV;
}