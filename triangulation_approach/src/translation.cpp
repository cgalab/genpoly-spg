#include "translation.h"

/*
	P ~ R ~ I ~ V ~ A ~ T ~ E 	M ~ E ~ M ~ B ~ E ~ R 	F ~ U ~ N ~ C ~ T ~ I ~ O ~ N ~ S
*/

/*
	Private Constructor:
	Generates a new translation of any type, whereas the publiuc constructor is just capable
	of generating translations of type DEFAULT. Grep the moving vertex and its neighbors from
	the triangulations vertices list and initalize the translation path.

	@param 	Tr 		The triangulation the moving vertex lives in
	@param 	i 		The index of the moving vertex in the triangulation
	@param 	dX 		The x-component of the translation vector
	@param 	dY 		The y-component of the translation vector
	@param	type 	The type of the translation

	Note:
		A translation of non-DEFAULT type can just be generated by a DEFAULT translation which
		must be split.
*/
Translation::Translation(Triangulation *Tr, int i, double dX, double dY, TranslationType tp) : 
	T(Tr), index(i), dx(dX), dy(dY), split(false), type(tp), actualTime(0) {

	original = (*T).getVertex(index);

	prevV = (*original).getPrev();
	nextV = (*original).getNext();

	oldV = (*original).getTranslated(0, 0);
	newV = (*original).getTranslated(dx, dy);

	transPath = new TEdge(oldV, newV);

	prevOldE = (*original).getToPrev();
	nextOldE = (*original).getToNext();

	prevNewE = new TEdge(prevV, newV);
	nextNewE = new TEdge(newV, nextV);

	Q = new EventQueue(original, oldV, newV);
}

/*
	The function generateInitialQueue() generates the initial version of the event queue. Therefore
	it decides for each triangle containing the moving vertex, whether the triangle will collapse
	during the translation. To achieve this it gets checked whether the opposite edge of the triangle
	lays between the start and the target position of the moving vertex.
	After inserting all collapsing triangles with their estimated collapse times into the event queue
	it lets check the event queue the stability of the event ordering and try to repair.

	@return 	True if the event queue is stable, otherwise false

	Note:
		This function also checks whether any of the triangles is zero and tries to repair it. If
		it finds something not repairable it erros with exit code 7.
*/
bool Translation::generateInitialQueue(){
	double t;
	std::list<Triangle*> triangles = (*original).getTriangles();
	TEdge *opposite;
	Vertex *v0, *v1;
	double areaOld, areaNew;
	Triangle *tr;
	bool ok;

	for(auto& i : triangles){
		opposite = (*i).getEdgeNotContaining(original);
		v0 = (*opposite).getV0();
		v1 = (*opposite).getV1();

		tr = new Triangle(v0, v1, oldV);
		areaOld = (*tr).signedArea();
		delete tr;

		// If the vertex lays at an edge at the begining of the translation then try to flip
		if(areaOld == 0){
			opposite = (*i).getLongestEdgeAlt();

			// If the longest edge is a polygon edge, then we have an error here
			if((*opposite).getEdgeType() == EdgeType::POLYGON){
				printf("The vertex %llu to be translated lays exactly on a polygon edge :0\n", (*original).getID());
				exit(7);
			}

			// TODO:
			// Probably the iterator won't work correct after this security flip

			// Otherwise we can do a flip
			printf("The moving vertex lays exactly on an edge before the translation -> security flip\n");
			flip(i, true);
			continue;
		}

		tr = new Triangle(v0, v1, newV);
		areaNew = (*tr).signedArea();
		delete tr;

		// Note: the triangle will also collapse if areaNew is exactly zero (zero can have both signs)
		if((areaNew != 0) && (signbit(areaOld) == signbit(areaNew)))
			continue;
		else{
			t = (*i).calculateCollapseTime(original, dx, dy);

			if(t < 0){
				printf("numerical correction: collapse time of collapsing triangle was %.20f \n", t);
				t = 0;
			}

			if(t > 1){
				printf("numerical correction: collapse time of collapsing triangle was %.20f \n", t);
				t = 1;
			}

			(*i).enqueue();

			(*Q).insertWithoutCheck(t, i);
		}
	}

	ok = (*Q).makeStable(true);

	return ok;
}

/*
	The function insideQuadrilateral() checks whether the vertex v lays inside of a quadrilateral
	formed by the edge from oldV to its neighboring  vertices and from newV to its neighboring
	vertices.
	Therefore it generates a dummy vertex with the same y-coordinate as v and a x-coordinate which
	is the maximum x-coordinate of all vertices of the triangle plus 10. So the dummy vertex lays
	definitelly outside of the qudrilateral. Then it checks how often the the edge between v and
	the dummy vertex intersects the edges of the quadrilateral. If the number of intersections is
	odd, then v must lay inside of the quadrilateral.

	@param 	v 	The vertex of interest
	@return 	True if v is inside of the quadrilateral, otherwise false

	Note:
		Source: https://www.geeksforgeeks.org/how-to-check-if-a-given-point-lies-inside-a-polygon/
*/
bool Translation::insideQuadrilateral(Vertex *v){
	Vertex *dummyVertex;
	TEdge *dummyEdge;
	double maxX, x;
	int count = 0;
	IntersectionType intersection;

	// Find maximum x value
	maxX = (*oldV).getX();
	x = (*newV).getX();
	if(x > maxX)
		maxX = x;
	x = (*prevV).getX();
	if(x > maxX)
		maxX = x;
	x = (*nextV).getX();
	if(x > maxX)
		maxX = x;

	// If v has a greater x-coordinate then all quadrilateral vertices, it can not be inside
	if((*v).getX() > maxX)
		return false;

	// Generate the dummy vertex outside of the quadrilateral
	maxX = maxX + 10;
	dummyVertex = new Vertex(maxX, (*v).getY());

	dummyEdge = new TEdge(v, dummyVertex);

	// Count the intersection
	// TODO:
	// Maybe using an epsilon here in checkIntersection makes no sense
	intersection = checkIntersection(dummyEdge, prevOldE);
	if(intersection != IntersectionType::NONE)
		count++;
	intersection = checkIntersection(dummyEdge, nextOldE);
	if(intersection != IntersectionType::NONE)
		count++;
	intersection = checkIntersection(dummyEdge, prevNewE);
	if(intersection != IntersectionType::NONE)
		count++;
	intersection = checkIntersection(dummyEdge, nextNewE);
	if(intersection != IntersectionType::NONE)
		count++;

	delete dummyEdge;
	delete dummyVertex;

	if(count % 2 == 1)
		return true;
	else
		return false;
}

/*
	The function checkEdge() checks whether the edge newE starting at vertex fromV intersects any
	polygon edge. Therefore it first checks whether newE intersects any edge of the surrounding
	polygon of fromV. If it does not, then it can not intersect any polygon edge, otherwise we
	continue the check in the other triangle assigned to the intersected edge until newE either
	intersects a polygon edge or ends in any triangle.

	@param 	fromV 	The vertex where the new edge starts
	@param 	newE 	The new edge
	@return 		True if the new edge does not intersect any polygon edge, otherwise false

	Note:
		- If the edge goes right through another vertex we also count it as intersecting a polygon
			edge even if the edge we checked was no polygon edge, because a new polygon edge
			obviously is not allowed to go through a vertex.
		- As we had the case that a new edge numerically intersected all three edges of the same
			triangle or multiple edges of the surrounding polygon we do not stopp at the first 
			intersection we find, but we count all intersections. If we find more then one, the
			function returns false.
		- Edges of the bounding box are treated as polygon edges
*/
// TODO:
// Check whether it can still appear, that a new edge interesect all edges of a triangle.
bool Translation::checkEdge(Vertex *fromV, TEdge *newE){
	std::vector<TEdge*> surEdges;
	enum IntersectionType iType = IntersectionType::NONE;
	enum IntersectionType iType0, iType1;
	TEdge *intersectedE = NULL;
	EdgeType eType;
	Triangle *nextT = NULL;
	int count = 0;

	surEdges = (*fromV).getSurroundingEdges();

	// Iterate over all edges of the surrounding polygon
	for(auto& i : surEdges){
		iType = checkIntersection(newE, i);

		// New edge hits vertex of surrounding polygon
		if(iType == IntersectionType::VERTEX)
			return false;

		// Count intersections to detect numerical errors
		if(iType == IntersectionType::EDGE){
			count++;
			intersectedE = i;
		}
	}

	// No intersection -> the new vertex stays in the surrounding polygon
	if(count == 0){
		return true;
	// Multiple intersections -> numerical error
	}else if(count > 1){
		if(Settings::feedback == FeedbackMode::VERBOSE)
			printf("CheckEdge: new edge intersects multiple edges of the surrounding polygon -> translation rejected due to numerical problem\n");
		return false;
	}

	// One real intersection with an edge of the surrounding polygon
	eType = (*intersectedE).getEdgeType();

	// Intersected edge is a polygon or frame edge
	if(eType != EdgeType::TRIANGULATION){
		return false;
	// Intersected edge is just a triangulation edge
	}else{
		nextT = (*intersectedE).getTriangleNotContaining(fromV);
		surEdges = (*nextT).getOtherEdges(intersectedE);
	}

	// Iterate over the adjacent triangles if there was an intersection with a triangulation edge
	// Here surEdges always have the length 2
	while(true){
		iType0 = checkIntersection(newE, surEdges[0]);
		iType1 = checkIntersection(newE, surEdges[1]);

		// The new edge does not interesect any further edges
		if(iType0 == IntersectionType::NONE && iType1 == IntersectionType::NONE)
			return true;

		// New edge hits a vertex
		if(iType0 == IntersectionType::VERTEX) 
			return false;
		if(iType1 == IntersectionType::VERTEX) 
			return false;

		// Check for numerical problems
		if(iType0 != IntersectionType::NONE && iType1 != IntersectionType::NONE){
			if(Settings::feedback == FeedbackMode::VERBOSE)
				printf("CheckEdge: new edge intersects multiple edges of the actual triangle -> translation rejected due to numerical problem\n");
			return false;
		}

		// Chose the intersected edge
		if(iType0 != IntersectionType::NONE){
			iType = iType0;
			intersectedE = surEdges[0];
		}else{
			iType = iType1;
			intersectedE = surEdges[1];
		}

		eType = (*intersectedE).getEdgeType();

		// intersected edge is a polygon or frame edge
		if(eType != EdgeType::TRIANGULATION){
			return false;
		// Intersected edge is just a triangulation edge
		}else{
			nextT = (*intersectedE).getOtherTriangle(nextT);
			surEdges = (*nextT).getOtherEdges(intersectedE);
		}
	}

	return true;
}

/*
	The function repairEnd() checks at the end of a translation whether there exist any triangle
	with area 0 connected to the moving vertex. If such a triangle exists it tries to flip it
	if possible, otherwise it tries to move the vertex back by 10% of the translation.

	Note:
		As the checkIntersection functions tries to keep vertices far from edges this should never
		be the case besides such splitted translation where the vertex is moved exactly to a
		triangulation edge on purpose.
*/
// TODO:
// Check whether this function does anything
void Translation::repairEnd(){
	std::list<Triangle*> triangles;
	double area;
	TEdge *edge;
	Translation *trans;
	enum Executed ex;

	triangles = (*original).getTriangles();

	for(auto& i : triangles){
		area = (*i).signedArea();

		if(area == 0){
			if(type == TranslationType::DEFAULT){
				printf("Translation: Triangle area = 0 after translation...");
				printf("start position\n");
				(*oldV).print();
				printf("target position\n");
				(*newV).print();
				printf("acutal end position\n");
				(*original).print();
			}

			edge = (*i).getLongestEdgeAlt();

			if(type == TranslationType::DEFAULT)
				printf("intersectiontype: %d\n", (int)checkIntersection(transPath, edge));

			// Try to do a security flip
			if((*edge).getEdgeType() != EdgeType::POLYGON)
				flip(i, true);
			// Otherwise try to move the vertex back a bit
			else{
				/*printf("\nTriangle area = 0 after translation: PE can not be fliped\n");
				printf("index: %d id: %llu dx: %f dy: %f\n", index, (*original).getID(), dx, dy);
				(*i).print();
				(*(*i).getVertex(0)).print();
				(*(*i).getVertex(1)).print();
				(*(*i).getVertex(2)).print();
				printf("oldv\n");
				(*oldV).print();
				printf("newV\n");
				(*newV).print();
				exit(2);*/

				trans = new Translation(T, index, - dx * 0.1, - dy * 0.1);
				ex = (*trans).execute();
				delete trans;

				if(ex == Executed::REJECTED){
					printf("\nTriangle area = 0 after translation: PE can not be fliped\n");
					exit(2);
				}
			}

			if(type == TranslationType::DEFAULT)
				printf("corrected! \n");
		}
	}
}


/*
	C ~ O ~ N ~ S ~ T ~ R ~ U ~ C ~ T ~ O ~ R ~ S
*/

/*
	Constructor:
	Generates a new Translation of type DEFAULT. Greps the moving vertex and its
	neighbors from the triangulations vertices list and initalize the translation path.

	@param 	Tr 		The triangulation the moving vertex lives in
	@param 	i 		The index of the moving vertex in the triangulation
	@param 	dX 		The x-component of the translation vector
	@param 	dY 		The y-component of the translation vector

	Note:
		Translations of other types can just be generated by the translation class itself.
*/
Translation::Translation(Triangulation *Tr, int i, double dX, double dY) :
	T(Tr), index(i), dx(dX), dy(dY), split(false), type(TranslationType::DEFAULT), actualTime(0) {

	original = (*T).getVertex(index);

	prevV = (*original).getPrev();
	nextV = (*original).getNext();

	oldV = (*original).getTranslated(0, 0);
	newV = (*original).getTranslated(dx, dy);

	transPath = new TEdge(oldV, newV);

	prevOldE = (*original).getToPrev();
	nextOldE = (*original).getToNext();

	prevNewE = new TEdge(prevV, newV);
	nextNewE = new TEdge(newV, nextV);

	Q = new EventQueue(original, oldV, newV);
}


/*
	O ~ T ~ H ~ E ~ R ~ S
*/

/*
	The function checkOverroll() checks whether the polygon would change its orientation by
	this translation. This basically means that the moving vertex is shifted across the whole
	polygon which corresponds to all other vertices and edges being inside of the qudrilateral
	formed by the oldV, the newV and their neighboring edges. Obviously if the quadrilateral is
	not simple, this can not happen at all. If the quadrilateral is simple then it corresponds
	to having one of the other vertices of the polygon inside the qudrilateral, because if
	one vertex is inside it follows all other vertices must be inside or at least one is outside
	so it exist at least one edge intersecting the quadrilateral so the translation can not lead
	to a simple polygon at all.

	@return 	True if the polygon would change its orientation, otherwise false
*/
bool Translation::checkOverroll(){
	bool overroll;
	Vertex *randomV;

	// Check whether the quadrilateral of the choosen Vertex P, its translated version P' and the
	// two neighbors M and N is simple, otherwise there can not be any overroll
	overroll = !(checkIntersection(prevOldE, nextNewE) != IntersectionType::NONE || checkIntersection(nextOldE, prevNewE) != IntersectionType::NONE);

	if(!overroll)
		return false;

	// Check for the next vertex whether it is inside the quadrilateral
	randomV = (*T).getVertex(index - 2);

	overroll = insideQuadrilateral(randomV);

	// Check also for a second vertex to increase the chance the reject non-simple translation
	randomV = (*T).getVertex(index + 2);

	overroll = overroll || insideQuadrilateral(randomV);

	return overroll;
}

/*
	The function execute() processes a translation. If the flag split is set, it splits the
	translation into two translations (depending on the geometric case) and executes them,
	otherwise it executes the translation by successively working through the events in the
	event queue.

	@return 	Indicates whether the execution was rejected, aborted or fully processed

	Note:
		For more information on the splits see my Master Thesis
*/
// TODO:
// Think of splitting this function in multiple functions for each case
enum Executed Translation::execute(){
	Triangle *t = NULL;
	std::pair<double, Triangle*> e;
	Translation *trans;
	double middleX, middleY, transX, transY, oldArea, newArea;
	TEdge *edge;
	Vertex *intersectionPoint;
	enum Executed ex;

	// The translation must be split into two translations
	if(split){
		t = new Triangle(prevV, nextV, oldV);
		oldArea = (*t).signedArea();
		delete t;

		t = new Triangle(prevV, nextV, newV);
		newArea = (*t).signedArea();
		delete t;

		// Vertex stays on the same side of the edge between the neighboring vertices
		if(signbit(oldArea) == signbit(newArea)){

			// Compute the intersection point to split the translation
			intersectionPoint = getIntersectionPoint(prevV, oldV, nextV, newV);
			if(intersectionPoint == NULL)
				intersectionPoint = getIntersectionPoint(nextV, oldV, prevV, newV);
			if(intersectionPoint == NULL){
				return Executed::REJECTED;
			}

			// First part of the translation to the intersection point
			transX = (*intersectionPoint).getX() - (*oldV).getX();
			transY = (*intersectionPoint).getY() - (*oldV).getY();

			trans = new Translation(T, index, transX, transY, TranslationType::SPLIT_PART_1);
			ex = (*trans).execute();

			delete intersectionPoint;
			delete trans;

			if(ex != Executed::FULL)
				return ex;

			// Second part of the translation from the intersection point to the target point
			transX = (*newV).getX() - (*original).getX();
			transY = (*newV).getY() - (*original).getY();

			trans = new Translation(T, index, transX, transY, TranslationType::SPLIT_PART_2);
			ex = (*trans).execute();

			delete trans;

			if(ex == Executed::FULL)
				return ex;
			else
				return Executed::PARTIAL;

		// Vertex changes side
		}else{
			
			// Get translation to end position of the first part which is the middle between the
			// neighboring vertices
			middleX = ((*prevV).getX() + (*nextV).getX()) / 2;
			middleY = ((*prevV).getY() + (*nextV).getY()) / 2;

			// Compute translation vector
			transX = middleX - (*oldV).getX();
			transY = middleY - (*oldV).getY();

			trans = new Translation(T, index, transX, transY, TranslationType::SPLIT_PART_1);
			ex = (*trans).execute();

			delete trans;

			if(ex != Executed::FULL)
				return ex;

			// For numerical reasons it is possible that the triangle of the old vertex and the
			// neighboring vertices doesn't vanish at the time when the vertex arrives between its
			// neighbors, therefore this must be checked and corrected before starting the second
			// translation
			edge = (*prevV).getEdgeTo(nextV);
			if(edge != NULL){
				t = (*edge).getTriangleContaining(original);
				flip(t, true);
			}

			// Get translation from middle to the target position
			transX = (*newV).getX() - (*original).getX();
			transY = (*newV).getY() - (*original).getY();

			trans = new Translation(T, index, transX, transY, TranslationType::SPLIT_PART_2);
			ex = (*trans).execute();

			delete trans;

			if(ex == Executed::FULL)
				return ex;
			else
				return Executed::PARTIAL;
		}

	// Default translation
	}else{
		
		if(!generateInitialQueue())
			return Executed::REJECTED;

		// Do till all events are processed
		while((*Q).size() > 0){
			e = (*Q).pop();
			actualTime = e.first;
			t = e.second;

			// Abort if the event queue becomes unstable
			if(!flip(t, false)){
				printf("aborted\n");
				return Executed::PARTIAL;
			}
		}

		// Move the vertex to its target position
		(*original).setPosition((*newV).getX(), (*newV).getY());

		return Executed::FULL;
	}
}

/*
	The function flip() executes one event by removing the longest edge of the collapsing triangle
	and inserting the other diagonal of the resulting quadrilateral. It errors with exit code 3 if
	the longest edge is a polygon edge. If the flip is no singleFlip it also computes whether the
	the two resulting triangles will also collapse during the further translation and in case insert
	them into the event queue and check its stability.

	@param 	t0 			The collapsing triangle
	@param 	singleFlip 	Indicates whether this flip is part of working off the event queue, or it is
						just a single security flip
	@return 			True if the event queue is still stable, otherwise false

	Note:
		- It is assumed that the area of the collapsing triangle is zero (or at least close to 0),
			i.e. the moving vertex is already shifted to the event time
		- Checking whether a resulting triangle will collapse during the further translation is
			a highly sensible thing! It is not recommend to use the actual position of the moving
			vertex therefore, because the small errors in its position can lead to wrong decisions
		- For more information on the method of deciding take a look into my Master Thesis
*/
// TODO:
// It is definitelly necessary to split this function into multiple functions!
bool Translation::flip(Triangle *t0, bool singleFlip){
	TEdge *e, *e1, *e2;
	Triangle *t1;
	Vertex *vj0, *vj1; // joint vertices
	Vertex *vn0, *vn1; // non-joint vertices
	// we call it an oppositeFlip, if the flipped edge is the one opposite to the moving vertex
	// i.e. it doesn't contain the moving vertex
	bool oppositeFlip;
	Vertex *dummyVertex;
	double x, y;
	double area0, area1;
	Triangle *dummyTriangle;
	bool insertion = false; //indicates whether a new triangle was inserted into the eventqueue
	double time;

	if(!singleFlip)
		// move vertex to event time
		(*original).setPosition((*oldV).getX() + dx * actualTime, (*oldV).getY() + dy * actualTime);

	// get the edge which should be flipped
	e = (*t0).getLongestEdgeAlt();
	if((*e).getEdgeType() == EdgeType::POLYGON){
		printf("Flip: polygon edge gets deleted\n");
		printf("id: %llu index: %d dx: %f dy: %f \n", (*original).getID(), index, dx, dy);

		(*T).check();
		exit(3);
	}

	// check for flip type
	if((*e).contains(original))
		oppositeFlip = false;
	else
		oppositeFlip = true;

	// remove the other triangle from the eventqueue if it is enqueued
	t1 =(*e).getOtherTriangle(t0);
	if((*t1).isEnqueued())
		(*Q).remove(t1);

	// get all vertices of the triangles which are removed
	vj0 = (*e).getV0();
	vj1 = (*e).getV1();
	vn0 = (*t0).getOtherVertex(e);
	vn1 = (*t1).getOtherVertex(e);

	delete e;

	// new triangle vn0, vn1, vj0
	e = new TEdge(vn0, vn1);
	(*T).addEdge(e);

	e1 = (*vj0).getEdgeTo(vn0);
	e2 = (*vj0).getEdgeTo(vn1);

	t0 = new Triangle(e, e1, e2, vn0, vn1, vj0);

	// new triangle vn0, vn1, vj1
	(*T).addEdge(e);

	e1 = (*vj1).getEdgeTo(vn0);
	e2 = (*vj1).getEdgeTo(vn1);

	t1 = new Triangle(e, e1, e2, vn0, vn1, vj1);

	if(!singleFlip){
		// reset coordinates temporarely to original position for the calcalation of the event time
		x = (*original).getX();
		y = (*original).getY();
		(*original).setPosition((*oldV).getX(), (*oldV).getY());

		// decide which of the new triangles has to be inserted into the eventqueue
		// if the opposite edge was flipped potentially both triangles can collapse in the future
		if(oppositeFlip){
			// first decide whether the non-moving vertex which is shared by both triangles
			// after the flip (we call it static vertex in the following)
			// is inside the corridor built by the two lines parallel to the transition line through
			// the non-shared vertices

			// find the static vertex (store in vn0)
			if((*vn0).getID() == (*original).getID())
				vn0 = vn1;

			dummyVertex = (*vj0).getTranslated(dx, dy);
			dummyTriangle = new Triangle(vj0, dummyVertex, vn0);
			area0 = (*dummyTriangle).signedArea();
			delete dummyTriangle;
			delete dummyVertex;

			dummyVertex = (*vj1).getTranslated(dx, dy);
			dummyTriangle = new Triangle(vj1, dummyVertex, vn0);
			area1 = (*dummyTriangle).signedArea();
			delete dummyTriangle;
			delete dummyVertex;

			// the static vertex is inside the corridor
			// i.e. both new triangles will collapse in the future
			if(signbit(area0) != signbit(area1)){
				// now we have to check for both new triangles, whether they collapse before
				// the end of the translation

				// for t0 (consisting of vn0, vn1, vj0)
				// we have to check the edge from the static vertex vn0 to the joint vertex vj0
				dummyTriangle = new Triangle(vn0, vj0, oldV);
				area0 = (*dummyTriangle).signedArea();
				delete dummyTriangle;

				dummyTriangle = new Triangle(vn0, vj0, newV);
				area1 = (*dummyTriangle).signedArea();
				delete dummyTriangle;

				// note: the triangle will also collapse if the test triangle with the new
				// vertex is exact zero (which can have both signs)
				if((area1 == 0) || (signbit(area0) != signbit(area1))){
					time = (*t0).calculateCollapseTime(original, dx, dy);
					(*Q).insertWithoutCheck(time, t0);
					(*t0).enqueue();
					insertion = true;
				}

				// for t1 (consisting of vn0, vn1, vj1)
				// we have to check the edge from the static vertex vn0 to the joint vertex vj1
				dummyTriangle = new Triangle(vn0, vj1, oldV);
				area0 = (*dummyTriangle).signedArea();
				delete dummyTriangle;

				dummyTriangle = new Triangle(vn0, vj1, newV);
				area1 = (*dummyTriangle).signedArea();
				delete dummyTriangle;

				if((area1 == 0) || (signbit(area0) != signbit(area1))){
					time = (*t1).calculateCollapseTime(original, dx, dy);
					(*Q).insertWithoutCheck(time, t1);
					(*t1).enqueue();
					insertion = true;
				}

			// the static vertex is not inside the corridor
			}else{
				// now we have to find out which of the two new triangles is the one which collapses
				// in the future

				// try t0 (consisting of vn0, original, vj0)
				// the non-joint vertex of t0 is vj0

				// now we can take a look whether the static and the moving vertex are on different sides
				// of the line parallel to the transition line through the non-joint vertex

				dummyVertex = (*vj0).getTranslated(dx, dy);

				dummyTriangle = new Triangle(vj0, dummyVertex, vn0);
				area0 = (*dummyTriangle).signedArea();
				delete dummyTriangle;

				dummyTriangle = new Triangle(vj0, dummyVertex, original);
				area0 = (*dummyTriangle).signedArea();
				delete dummyTriangle;

				delete dummyVertex;

				// if they are on different sides, then t1 is the triangle which will collapse in the future
				// t1 consists of original, vn0 (static) and vj1
				if(signbit(area0) != signbit(area1)){
					// now we have to check whether the triangle t1 collapses before the end of the translation
					// i.e. start and end position have to be on different side of the edge (vn0, vj1)

					dummyTriangle = new Triangle(vn0, vj1, oldV);
					area0 = (*dummyTriangle).signedArea();
					delete dummyTriangle;

					dummyTriangle = new Triangle(vn0, vj1, newV);
					area1 = (*dummyTriangle).signedArea();
					delete dummyTriangle;

					if((area1 == 0) || (signbit(area0) != signbit(area1))){
						time = (*t1).calculateCollapseTime(original, dx, dy);
						(*Q).insertWithoutCheck(time, t1);
						(*t1).enqueue();
						insertion = true;
					}
				}else{
					// now we have to check whether the triangle t0 collapses before the end of the translation
					// i.e. start and end position have to be on different side of the edge (vn0, vj0)

					dummyTriangle = new Triangle(vn0, vj0, oldV);
					area0 = (*dummyTriangle).signedArea();
					delete dummyTriangle;

					dummyTriangle = new Triangle(vn0, vj0, newV);
					area1 = (*dummyTriangle).signedArea();
					delete dummyTriangle;

					if((area1 == 0) || (signbit(area0) != signbit(area1))){
						time = (*t0).calculateCollapseTime(original, dx, dy);
						(*Q).insertWithoutCheck(time, t0);
						(*t0).enqueue();
						insertion = true;
					}
				}
			}


		// a non-opposite edge was flipped, so just one triangle can collapse in the future
		}else{
			// the new triangle will collapse in the future if the non-joint vertex of the triangle
			// which won't change anymore is on the same side of the new edge (vn0, vn1) as the 
			// target position is


			// find the static vertex (store in vj0)
			if((*vj0).getID() == (*original).getID())
				vj0 = vj1;

			dummyTriangle = new Triangle(vn0, vn1, vj0);
			area0 = (*dummyTriangle).signedArea();
			delete dummyTriangle;

			dummyTriangle = new Triangle(vn0, vn1, newV);
			area1 = (*dummyTriangle).signedArea();
			delete dummyTriangle;

			// otherwise none of the two new triangles will collapse in the future
			if(signbit(area0) == signbit(area1)){
				// get the triangle which still contains the moving vertex
				if(!(*t0).contains(original))
					t0 = t1;

				// now we have to check whether the new triangle will collapse before the
				// translation ends, i.e. the start position end the end position of the movements
				// are on different sides of the new edge which is given by vn0 and vn1

				dummyTriangle = new Triangle(vn0, vn1, oldV);
				area0 = (*dummyTriangle).signedArea();
				delete dummyTriangle;

				dummyTriangle = new Triangle(vn0, vn1, newV);
				area1 = (*dummyTriangle).signedArea();
				delete dummyTriangle;

				if((area1 == 0) || (signbit(area0) != signbit(area1))){
					time = (*t0).calculateCollapseTime(original, dx, dy);
					(*Q).insertWithoutCheck(time, t0);
					(*t0).enqueue();
					insertion = true;
				}
			}
		}

		// get original back to actual position
		(*original).setPosition(x, y);

		if(insertion)
			return (*Q).makeStable(false);
		else
			return true;
	}

	return true;
}

/*
	The function checkSimplicityOfTranslation() determines whether the result of a translation is
	a simple polygon. It does so by checking whether one of the edges from the new vertex position
	to one of its neighbors intersects a polygon edge.

	@return 	True if the resulting polygon is still simple, otherwise false
*/
bool Translation::checkSimplicityOfTranslation(){
	bool simple;

	(*prevOldE).setEdgeType(EdgeType::TRIANGULATION);
	(*nextOldE).setEdgeType(EdgeType::TRIANGULATION);

	simple = checkEdge(prevV, prevNewE);
	simple = simple && checkEdge(nextV, nextNewE);

	(*prevOldE).setEdgeType(EdgeType::POLYGON);
	(*nextOldE).setEdgeType(EdgeType::POLYGON);

	return simple;
}

/*
	The function checkSplit() determines whether a translation can be executed directly or must
	be split into two translation. This corresponds to the question whether the translation path
	intersects any polygon edge or not. If the translation must be split the function sets the
	internal split flag.
*/
void Translation::checkSplit(){
	split = !checkEdge(original, transPath);
}


/*
	D ~ E ~ S ~ T ~ R ~ U ~ C ~ T ~ O ~ R
*/

/*
	Destructor:
	Checks and potentially repairs the surrounding polygon of the moved vertex and deletes all
	the remaining construction vertices and edges. It errors with exit code 6 if the surrounding
	polygon check fails.
*/	
Translation::~Translation(){
	bool ok;

	repairEnd();

	ok = (*original).checkSurroundingPolygon();

	if(!ok){
		printf("\nstart position:\n");
		(*oldV).print();
		printf("original position:\n");
		(*original).print();
		printf("target position:\n");
		(*newV).print();
		printf("translation vector: dx = %.20f dy = %.20f \n", dx, dy);

		(*T).print("bug.graphml");

		exit(6);
	}

	delete transPath;
	delete oldV;
	delete newV;
}
